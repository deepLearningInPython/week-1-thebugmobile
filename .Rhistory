reticulate::repl_python()
installr
quit
installr
install.packages("installr")
?installr
??installr
library(installr)
updateR()
reticulate::repl_python()
import numpy as np
from tasks import step
# Test cases for Task 1: step function
def test_step_positive():
assert step(5) == 1, "Failed on positive input"
def test_step_negative():
assert step(-3) == -1, "Failed on negative input"
def test_step_zero():
assert step(0) == -1, "Failed on zero input"
import numpy
install.packages("reticulate")
quit
install.packages("reticulate")
library(reticulate)
py_config()
np <- import("numpy")
np$zeros(5)
py_install("numpy")
np <- import("numpy")
np$zeros(5)
np$zeros(as.integer(5))
reticulate::repl_python()
import numpy
quit
py_config()  # Shows the current Python environment and paths
reticulate::repl_python()
import numpy
quit
library(reticulate)
use_virtualenv("r-reticulate", required = TRUE)
reticulate::repl_python()
import numpy as np
print(np.zeros(5))
import numpy
def test_step_positive():
assert step(5) == 1, "Failed on positive input"
# Test cases for Task 1: step function
def test_step_positive():
assert step(5) == 1, "Failed on positive input"
def test_step_negative():
assert step(-3) == -1, "Failed on negative input"
def test_step_zero():
assert step(0) == -1, "Failed on zero input"
import numpy as np
from tasks import step
quit
setwd("~/OneDrive/Documents/BDSMaster/deep learning in python/week 1/week-1-tabea")
reticulate::repl_python()
# Test cases for Task 1: step function
def test_step_positive():
assert step(5) == 1, "Failed on positive input"
def test_step_negative():
assert step(-3) == -1, "Failed on negative input"
def test_step_zero():
assert step(0) == -1, "Failed on zero input"
import numpy as np
from tasks import step
def neural_net_layer(x(n, p), y(p)):
def neural_net_layer(x, y):
if x.ndim != 2 or y.ndim != 1 or x.shape[1] != y.shape[0]:
raise ValueError("Invalid input shapes: x should be (n, p) and y should be (p,)")
w = x@y
return(ReLu(w))
def neural_net_layer(x, y):
if x.ndim != 2 or y.ndim != 1 or x.shape[1] != y.shape[0]:
raise ValueError("Invalid input shapes: x should be (n, p) and y should be (p,)")
w = x@y
return(ReLu(w))
def neural_net_layer(x, y):
if x.ndim != 2 or y.ndim != 1 or x.shape[1] != y.shape[0]:
raise ValueError("Invalid input shapes: x should be (n, p) and y should be (p,)")
w = x@y
return(ReLu(w))
from tasks import step
# Test cases for Task 1: step function
def test_step_positive():
assert step(5) == 1, "Failed on positive input"
def test_step_negative():
assert step(-3) == -1, "Failed on negative input"
def test_step_zero():
assert step(0) == -1, "Failed on zero input"
# Test cases for Task 1: step function
def test_step_positive():
assert step(5) == 1, "Failed on positive input"
def test_step_negative():
assert step(-3) == -1, "Failed on negative input"
def test_step_zero():
assert step(0) == -1, "Failed on zero input"
x = np.array([[1, 2, 3],
[4, 5, 6],
[7, 8, 9]])
# Sample 1D array (p,)
y = np.array([1, 0, -1])  # y must have the same length as the number of columns in x
# Call the neural_net_layer function
result = neural_net_layer(x, y)
print(result)  # Output: ReLu applied to the result of the multiplication
result = neural_net_layer(x, y)
# Your code here:
# -----------------------------------------------
def ReLu(x, cutoff=0):
return np.where(arr < cutoff, cutoff, arr)
# ------------------------------
# Sample 2D array (n, p)
x = np.array([[1, 2, 3],
[4, 5, 6],
[7, 8, 9]])
# Sample 1D array (p,)
y = np.array([1, 0, -1])  # y must have the same length as the number of columns in x
# Call the neural_net_layer function
result = neural_net_layer(x, y)
print(result)  # Output: ReLu applied to the result of the multiplication
# Sample 2D array (n, p)
x = np.array([[1, 2, 3],
[4, 5, 6],
[7, 8, 9]])
# Sample 1D array (p,)
y = np.array([1, 0, -1])  # y must have the same length as the number of columns in x
# Call the neural_net_layer function
result = neural_net_layer(x, y)
print(result)  # Output: ReLu applied to the result of the multiplication
# Sample 2D array (n, p)
x = np.array([[1, 2, 3],
[4, 5, 6],
[7, 8, 9]])
# Sample 1D array (p,)
y = np.array([1, 0, -1])  # y must have the same length as the number of columns in x
# Call the neural_net_layer function
result = neural_net_layer(x, y)
print(result)  # Output: ReLu applied to the result of the multiplication
def ReLu(x, cutoff=0):
return np.where(x < cutoff, cutoff, x)
x = np.array([[1, 2, 3],
[4, 5, 6],
[7, 8, 9]])
# Sample 1D array (p,)
y = np.array([1, 0, -1])  # y must have the same length as the number of columns in x
# Call the neural_net_layer function
result = neural_net_layer(x, y)
print(result)  # Output: ReLu applied to the result of the multiplication
x = np.array([[1, 2, 3],
[4, 5, 6],
[7, 8, 9]])
# Sample 1D array (p,)
y = np.array([1, 0, -1])  # y must have the same length as the number of columns in x
# Call the neural_net_layer function
result = neural_net_layer(x, y)
print(result)  # Output: ReLu applied to the result of the multiplication
# Sample 2D array (n, p)
x = np.array([[1, 2, 3],
[4, 5, 6],
[7, 8, 9]])
# Sample 1D array (p,)
y = np.array([6, 6, 6])  # y must have the same length as the number of columns in x
# Call the neural_net_layer function
result = neural_net_layer(x, y)
print(result)  # Output: ReLu applied to the result of the multiplication
def test_step_positive():
assert step(5) == 1, "Failed on positive input"
def test_step_negative():
from tasks import step
# Test cases for Task 1: step function
def test_step_positive():
assert step(5) == 1, "Failed on positive input"
def test_step_negative():
assert step(-3) == -1, "Failed on negative input"
def test_step_zero():
def test_step_positive():
assert step(5) == 1, "Failed on positive input"
View(ReLu)
from tasks import step, ReLu
def test_relu_default_cutoff():
array = np.array([-5, 0, 3, -2, 4])
expected_output = np.array([0, 0, 3, 0, 4])
np.testing.assert_array_equal(ReLu(array.copy()), expected_output, "Failed on default cutoff")
def test_relu_custom_cutoff():
array = np.array([-5, 0, 3, -2, 4])
expected_output = np.array([2, 2, 3, 2, 4])
np.testing.assert_array_equal(ReLu(array.copy(), 2), expected_output, "Failed on custom cutoff")
def test_relu_empty_array():
array = np.array([])
expected_output = np.array([])
np.testing.assert_array_equal(ReLu(array.copy()), expected_output, "Failed on empty array")
pip install pytest
pip install pytest
import numpy as np
from tasks import step
# Test cases for Task 1: step function
def test_step_positive():
assert step(5) == 1, "Failed on positive input"
def test_step_negative():
assert step(-3) == -1, "Failed on negative input"
def test_step_zero():
assert step(0) == -1, "Failed on zero input"
View(test_step_zero)
import numpy as np
from tasks import step
# Test cases for Task 1: step function
def test_step_positive():
assert step(5) == 1, "Failed on positive input"
def test_step_negative():
assert step(-3) == -1, "Failed on negative input"
def test_step_zero():
assert step(0) == -1, "Failed on zero input"
test_step_zero(0)
